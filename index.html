<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Record Your Story ‚Äî Safe Recorder (Multi‚ÄëTake)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{ --bg:#ffffff; --fg:#222; --muted:#666; --accent:#1B4D3E; --warn:#C0392B; --ok:#2E7D32; --btn:#ccc; }
    html,body{background:var(--bg);color:var(--fg)}
    body { font-family: 'Georgia', serif; text-align: center; margin: 40px auto; padding: 0 20px; max-width: 760px; }
    h1 { margin-bottom: 6px; }
    p.lead { margin-top: 0; color: var(--muted); }
    button { font-size: 20px; padding: 16px 28px; margin: 12px; border-radius: 10px; border: none; background: var(--btn); cursor: pointer; min-width: 200px; box-shadow: 0 2px 0 rgba(0,0,0,.08); }
    button[disabled]{ opacity:.55; cursor:not-allowed }
    audio { margin: 8px 0; display: block; width: 100%; max-width: 520px; }
    .status { font-size: 16px; margin-top: 14px; min-height: 22px; }
    #logo { margin-top: 26px; width: 150px; }
    #questionDisplay { font-style: italic; max-width: 640px; margin: 12px auto 20px; font-size: 18px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:14px; vertical-align: middle; }
    .pill.ok { background: #E8F5E9; color: var(--ok); }
    .pill.warn { background: #FDECEA; color: var(--warn); }
    .bar-wrap{ margin:8px auto 0; width:240px; height:10px; background:#eee; border-radius:999px; overflow:hidden; }
    .bar{ height:100%; width:0%; background: linear-gradient(90deg, #8BC34A, #FFC107); transition: width .18s linear; }
    .tips { font-size: 14px; color: var(--muted); margin-top: 10px; }
    .take { text-align:left; margin: 10px 0; padding: 10px; border: 1px solid #eee; border-radius: 10px; }
    .take header { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    @media (max-width: 480px) { button { font-size: 22px; padding: 18px 32px; min-width: 90%; } }
  </style>
</head>
<body>
  <h1>Record Your Story</h1>
  <p class="lead">Press "Start Recording" to begin. Click "Stop Recording" to save a take. You can record multiple takes and choose which one to submit.</p>

  <!-- üß† Display the question -->
  <div id="questionDisplay"></div>

  <!-- Mic health indicator -->
  <div id="micRow" aria-live="polite" style="margin:10px 0 18px;">
    <span id="micPill" class="pill warn">Mic not active</span>
    <div class="bar-wrap" aria-hidden="true"><div id="levelBar" class="bar"></div></div>
    <div class="tips">If the bar doesn't move when you talk, check browser mic permissions and device settings.</div>
  </div>

  <!-- üéôÔ∏è Recording controls -->
  <div>
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop Recording</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="deleteBtn" disabled>Delete Selected Take</button>
    <button id="submitBtn" disabled>Submit Selected Take</button>
  </div>

  <div id="takesContainer" style="margin-top: 12px;"></div>
  <div id="status" class="status" role="status" aria-live="polite"></div>

  <img id="logo" src="logo.png" alt="Life In Voices Logo" />

  <script>
    // ======= Configurable thresholds =======
    const SILENCE_THRESHOLD = 0.010;   // Lower sensitivity so brief pauses don't flip state
    const SILENCE_WINDOW_MS = 3000;
    const MIN_GOOD_MS = 1500;
    const MIN_DURATION_MS = 1000;
    const MIN_SIZE_BYTES = 5000;

    let mediaRecorder, audioChunks = [], audioBlob;
    let isPaused = false;
    let stream, audioCtx, analyser, sourceNode;
    let levelTimer = null, startTime = 0, stopTime = 0, silentStreakMs = 0, totalChecks = 0, silentChecks = 0, goodAudioMs = 0;
    let takes = [];

    const els = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      deleteBtn: document.getElementById('deleteBtn'),
      submitBtn: document.getElementById('submitBtn'),
      takes: document.getElementById('takesContainer'),
      status: document.getElementById('status'),
      question: document.getElementById('questionDisplay'),
      micPill: document.getElementById('micPill'),
      levelBar: document.getElementById('levelBar'),
    };

    const urlParams = new URLSearchParams(window.location.search);
    const name = urlParams.get('name') || "unknown";
    const email = urlParams.get('email') || "noemail";
    const week = urlParams.get('week');
    const questionId = urlParams.get('questionId');
    const rawText = urlParams.get('questionText');

    // üé§ Generate filename base
    let base = questionId ? `LIV_${name}_${email}_${questionId}`
                : week ? `LIV_${name}_${email}_Week${week}`
                : `LIV_${name}_${email}`;

    // üß† Display and decode the question text
    if (rawText) {
      try {
        const cleaned = rawText.trim();
        const decoded = decodeURIComponent(cleaned);
        els.question.textContent = `‚Äú${decoded}‚Äù`;
        urlParams.delete("questionText");
        const cleanUrl = window.location.pathname + "?" + urlParams.toString();
        window.history.replaceState({}, document.title, cleanUrl);
      } catch (e) { els.question.textContent = "‚ùì Unable to display question."; }
    }

    // ======= Mic / level helpers =======
    function setupAnalyser(msStream){
      if (audioCtx) { try{ audioCtx.close(); }catch{} }
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(msStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
    }

    function getRMS(){
      const buffer = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(buffer);
      let sum = 0;
      for (let i=0;i<buffer.length;i++){
        const v = (buffer[i] - 128) / 128; // -1..1
        sum += v*v;
      }
      return Math.sqrt(sum / buffer.length); // 0..1
    }

    function startLevelMonitor(){
      if (!analyser) return;
      const interval = 250; // steadier updates
      levelTimer = setInterval(()=>{
        if (!analyser) return;
        const rms = getRMS();
        els.levelBar.style.width = Math.min(100, Math.round(rms*160)) + '%';
        const now = performance.now();
        totalChecks++;
        if (rms < SILENCE_THRESHOLD){
          silentChecks++; silentStreakMs += interval;
        } else {
          goodAudioMs += interval; silentStreakMs = 0;
        }
        if (rms < SILENCE_THRESHOLD) { els.micPill.textContent = 'Listening‚Ä¶'; els.micPill.className = 'pill warn'; }
        else { els.micPill.textContent = 'Mic input detected'; els.micPill.className = 'pill ok'; }
        if (startTime && (now - startTime > 1200) && silentStreakMs >= SILENCE_WINDOW_MS){
          els.status.innerHTML = '‚ö†Ô∏è We cannot detect any microphone input. Please check your mic permissions, mute switch, or device settings, then try again.';
        }
      }, interval);
    }

    function stopLevelMonitor(){ if (levelTimer){ clearInterval(levelTimer); levelTimer = null; } if (audioCtx){ try{ audioCtx.close(); }catch{} audioCtx=null; } analyser = null; sourceNode = null; els.levelBar.style.width = '0%'; els.micPill.textContent = 'Mic not active'; els.micPill.className = 'pill warn'; }

    function resetForNewTake(){
      // Do NOT clear existing takes; just prep buffers for a new take
      audioChunks = []; audioBlob = null; isPaused = false;
      els.deleteBtn.disabled = takes.length === 0;
      els.submitBtn.disabled = takes.length === 0;
      els.pauseBtn.disabled = true; els.stopBtn.disabled = true; els.startBtn.disabled = false;
      els.status.textContent = '';
      silentStreakMs = 0; totalChecks = 0; silentChecks = 0; goodAudioMs = 0; startTime = 0; stopTime = 0;
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      stopLevelMonitor();
    }

    function renderTakes(){
      els.takes.innerHTML = '';
      takes.forEach((t, i) => {
        const row = document.createElement('div'); row.className = 'take';
        const header = document.createElement('header');
        const radio = document.createElement('input'); radio.type = 'radio'; radio.name = 'selectedTake'; radio.value = String(i); if (i === takes.length - 1) radio.checked = true;
        const title = document.createElement('strong'); title.textContent = `${t.label}`;
        header.appendChild(radio); header.appendChild(title); row.appendChild(header);
        const audioEl = document.createElement('audio'); audioEl.controls = true; audioEl.src = t.url; row.appendChild(audioEl);
        els.takes.appendChild(row);
      });
    }

    // ======= UI wire-up =======
    els.startBtn.onclick = async () => {
      try {
        resetForNewTake();
        stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
        });
        try { const [track] = stream.getAudioTracks(); await track.applyConstraints({ echoCancellation: false, noiseSuppression: false, autoGainControl: false }); } catch {}
        setupAnalyser(stream); startLevelMonitor();

        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };
        mediaRecorder.onstart = () => { startTime = Date.now(); els.status.textContent = 'üéôÔ∏è Recording‚Ä¶'; };
        mediaRecorder.onpause = () => { els.status.textContent = '‚è∏Ô∏è Recording paused.'; };
        mediaRecorder.onresume = () => { els.status.textContent = 'üéôÔ∏è Recording resumed‚Ä¶'; };
        mediaRecorder.onstop = () => {
          stopTime = Date.now(); stopLevelMonitor();
          if (!audioChunks.length){ els.status.innerHTML = '‚ùå No audio data was captured. Please check your microphone and try again.'; return; }
          audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(audioBlob);
          const takeIndex = takes.length + 1; const label = `Take ${takeIndex}`;
          takes.push({ blob: audioBlob, url: audioUrl, label });
          renderTakes();
          els.deleteBtn.disabled = false; els.submitBtn.disabled = false; els.pauseBtn.disabled = true;

          const durMs = stopTime - startTime;
          const silentRatio = totalChecks ? (silentChecks/totalChecks) : 1;
          const size = audioBlob.size || 0;
          let problems = [];
          if (durMs < MIN_DURATION_MS) problems.push('This take is very short');
          if (goodAudioMs < MIN_GOOD_MS) problems.push("We didn't detect clear mic input");
          if (silentRatio > 0.95) problems.push('This take was mostly silent');
          if (size < MIN_SIZE_BYTES) problems.push('File size looks too small');

          if (problems.length){ els.submitBtn.disabled = true; els.status.innerHTML = `‚ö†Ô∏è ${problems.join('; ')}. You can record another take or delete this one.`; }
          else { els.status.innerHTML = `üéß ${label} saved. You can record another take or submit.`; }
        };

        mediaRecorder.start(250); // flush chunks while recording
        isPaused = false; els.startBtn.disabled = true; els.stopBtn.disabled = false; els.pauseBtn.disabled = false; els.pauseBtn.textContent = 'Pause';

        const [track] = stream.getAudioTracks();
        track.onmute = () => { els.status.innerHTML = '‚ö†Ô∏è Your microphone was muted by the system/browser. Unmute to continue.'; };
        track.onunmute = () => { els.status.innerHTML = 'üéôÔ∏è Microphone active again.'; };
        track.onended = () => { if (mediaRecorder && mediaRecorder.state !== 'inactive') { try{ mediaRecorder.stop(); }catch{} } };
      } catch (err) {
        els.status.innerHTML = '‚ùå Unable to access microphone: ' + (err && err.message ? err.message : err);
      }
    };

    els.pauseBtn.onclick = () => {
      if (!mediaRecorder) return;
      if (!isPaused) { mediaRecorder.pause(); isPaused = true; els.pauseBtn.textContent = 'Resume'; }
      else { mediaRecorder.resume(); isPaused = false; els.pauseBtn.textContent = 'Pause'; }
    };

    els.stopBtn.onclick = () => {
      try { mediaRecorder && mediaRecorder.state !== 'inactive' && mediaRecorder.stop(); } catch {}
      els.startBtn.disabled = false; els.stopBtn.disabled = true; els.pauseBtn.disabled = true; els.pauseBtn.textContent = 'Pause';
    };

    els.deleteBtn.onclick = () => {
      const selected = document.querySelector('input[name="selectedTake"]:checked');
      let idx = selected ? parseInt(selected.value, 10) : takes.length - 1;
      if (idx < 0) return;
      takes.splice(idx, 1);
      renderTakes();
      els.submitBtn.disabled = takes.length === 0; els.deleteBtn.disabled = takes.length === 0;
      els.status.textContent = takes.length ? 'üóëÔ∏è Take deleted.' : 'üóëÔ∏è All takes deleted. Start again when ready.';
    };

    // üì§ Submit selected take
    els.submitBtn.onclick = async () => {
      if (!takes.length) { els.status.textContent = '‚ö†Ô∏è No take to submit.'; return; }
      const selected = document.querySelector('input[name="selectedTake"]:checked');
      const idx = selected ? parseInt(selected.value, 10) : (takes.length - 1);
      const chosen = takes[idx];

      if (!chosen || !chosen.blob || chosen.blob.size < MIN_SIZE_BYTES) { els.status.innerHTML = '‚ùå Selected take looks invalid. Please record again.'; return; }

      const formData = new FormData();
      const filename = `${base}.webm`;
      formData.append('file', chosen.blob, filename);
      try {
        const response = await fetch('https://hook.eu2.make.com/nsbtpvkksxfjkifpe2our0hxn5ykf6ip', { method: 'POST', body: formData });
        if (response.ok) { els.status.innerHTML = '‚úÖ Recording submitted successfully'; els.submitBtn.disabled = true; els.deleteBtn.disabled = true; }
        else { els.status.textContent = '‚ùå Failed to submit recording.'; }
      } catch (error) { els.status.textContent = '‚ùå Upload error: ' + error.message; }
    };
  </script>
</body>
</html>
