<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Record Your Story ‚Äî Safe Recorder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --bg:#ffffff; --fg:#222; --muted:#666; --accent:#1B4D3E; --warn:#C0392B; --ok:#2E7D32; --btn:#ccc;
    }
    html,body{background:var(--bg);color:var(--fg)}
    body { font-family: 'Georgia', serif; text-align: center; margin: 40px auto; padding: 0 20px; max-width: 760px; }
    h1 { margin-bottom: 6px; }
    p.lead { margin-top: 0; color: var(--muted); }
    button { font-size: 20px; padding: 16px 28px; margin: 12px; border-radius: 10px; border: none; background: var(--btn); cursor: pointer; min-width: 200px; box-shadow: 0 2px 0 rgba(0,0,0,.08); }
    button[disabled]{ opacity:.55; cursor:not-allowed }
    audio { margin: 20px auto; display: block; width: 100%; max-width: 520px; }
    .status { font-size: 16px; margin-top: 14px; min-height: 22px; }
    #logo { margin-top: 26px; width: 150px; }
    #questionDisplay { font-style: italic; max-width: 640px; margin: 12px auto 20px; font-size: 18px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:14px; vertical-align: middle; }
    .pill.ok { background: #E8F5E9; color: var(--ok); }
    .pill.warn { background: #FDECEA; color: var(--warn); }
    .bar-wrap{ margin:8px auto 0; width:240px; height:10px; background:#eee; border-radius:999px; overflow:hidden; }
    .bar{ height:100%; width:0%; background: linear-gradient(90deg, #8BC34A, #FFC107); transition: width .12s linear; }
    .tips { font-size: 14px; color: var(--muted); margin-top: 10px; }
    .error { color: var(--warn); }
    .success { color: var(--ok); }
    .sr-only{ position:absolute; left:-9999px; }
    @media (max-width: 480px) { button { font-size: 22px; padding: 18px 32px; min-width: 90%; } }
  </style>
</head>
<body>
  <h1>Record Your Story</h1>
  <p class="lead">Press "Start Recording" to begin. You can delete and retry as many times as you like. Only click submit when you're happy with your recording.</p>

  <!-- üß† Display the question -->
  <div id="questionDisplay"></div>

  <!-- Mic health indicator -->
  <div id="micRow" aria-live="polite" style="margin:10px 0 18px;">
    <span id="micPill" class="pill warn">Mic not active</span>
    <div class="bar-wrap" aria-hidden="true"><div id="levelBar" class="bar"></div></div>
    <div class="tips">If the bar doesn't move when you talk, check browser mic permissions and device settings.</div>
  </div>

  <!-- üéôÔ∏è Recording controls -->
  <div>
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop Recording</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="deleteBtn" disabled>Delete Recording</button>
    <button id="submitBtn" disabled>Submit Recording</button>
  </div>

  <div id="previewContainer" style="margin-top: 12px;"></div>
  <div id="status" class="status" role="status" aria-live="polite"></div>

  <img id="logo" src="logo.png" alt="Life In Voices Logo" />

  <script>
    // ======= Configurable thresholds =======
    const SILENCE_THRESHOLD = 0.018;   // RMS below this is considered "silence" (0..1). Adjust if needed.
    const SILENCE_WINDOW_MS = 3000;    // If continuous silence for this long after recording starts, warn user.
    const MIN_GOOD_MS = 1500;          // Require at least this much non-silent audio before allowing submit
    const MIN_DURATION_MS = 1000;      // Clip must be at least this long
    const MIN_SIZE_BYTES = 5000;       // Blob must be at least this large to be considered valid

    let mediaRecorder, audioChunks = [], audioBlob;
    let isPaused = false;
    let stream, audioCtx, analyser, sourceNode;
    let levelTimer = null, startTime = 0, stopTime = 0, silentStreakMs = 0, totalChecks = 0, silentChecks = 0, goodAudioMs = 0;

    const els = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      deleteBtn: document.getElementById('deleteBtn'),
      submitBtn: document.getElementById('submitBtn'),
      preview: document.getElementById('previewContainer'),
      status: document.getElementById('status'),
      question: document.getElementById('questionDisplay'),
      micPill: document.getElementById('micPill'),
      levelBar: document.getElementById('levelBar'),
    };

    const urlParams = new URLSearchParams(window.location.search);
    const name = urlParams.get('name') || "unknown";
    const email = urlParams.get('email') || "noemail";
    const week = urlParams.get('week');
    const questionId = urlParams.get('questionId');
    const rawText = urlParams.get('questionText');

    // üé§ Generate filename
    let filename = questionId ? `LIV_${name}_${email}_${questionId}.wav`
                : week ? `LIV_${name}_${email}_Week${week}.wav`
                : `LIV_${name}_${email}.wav`;

    // üß† Display and decode the question text
    if (rawText) {
      try {
        const cleaned = rawText.trim();
        const decoded = decodeURIComponent(cleaned);
        els.question.textContent = `‚Äú${decoded}‚Äù`;
        urlParams.delete("questionText");
        const cleanUrl = window.location.pathname + "?" + urlParams.toString();
        window.history.replaceState({}, document.title, cleanUrl);
      } catch (e) { els.question.textContent = "‚ùì Unable to display question."; }
    }

    // ======= Mic / level helpers =======
    function setupAnalyser(msStream){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(msStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
    }

    function getRMS(){
      const buffer = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(buffer);
      let sum = 0;
      for (let i=0;i<buffer.length;i++){
        const v = (buffer[i] - 128) / 128; // -1..1
        sum += v*v;
      }
      return Math.sqrt(sum / buffer.length); // 0..1
    }

    function startLevelMonitor(){
      if (!analyser) return;
      const interval = 150; // ms
      levelTimer = setInterval(()=>{
        if (!analyser) return;
        const rms = getRMS();
        els.levelBar.style.width = Math.min(100, Math.round(rms*160)) + '%';
        const now = performance.now();
        totalChecks++;
        if (rms < SILENCE_THRESHOLD){
          silentChecks++;
          silentStreakMs += interval;
        } else {
          goodAudioMs += interval;
          silentStreakMs = 0;
        }
        // Pill status
        if (rms < SILENCE_THRESHOLD) {
          els.micPill.textContent = 'Listening‚Ä¶ (very low mic input)';
          els.micPill.className = 'pill warn';
        } else {
          els.micPill.textContent = 'Mic input detected';
          els.micPill.className = 'pill ok';
        }
        // Early warning if totally silent for a while after start
        if (startTime && (now - startTime > 1200) && silentStreakMs >= SILENCE_WINDOW_MS){
          els.status.innerHTML = '‚ö†Ô∏è We cannot detect any microphone input. Please check your mic permissions, mute switch, or device settings, then try again.';
        }
      }, interval);
    }

    function stopLevelMonitor(){
      if (levelTimer){ clearInterval(levelTimer); levelTimer = null; }
      if (audioCtx){ try{ audioCtx.close(); }catch{} audioCtx = null; }
      analyser = null; sourceNode = null;
      els.levelBar.style.width = '0%';
      els.micPill.textContent = 'Mic not active';
      els.micPill.className = 'pill warn';
    }

    function hardReset(){
      audioChunks = []; audioBlob = null; isPaused = false;
      els.preview.innerHTML = '';
      els.deleteBtn.disabled = true; els.submitBtn.disabled = true; els.pauseBtn.disabled = true;
      els.startBtn.disabled = false; els.stopBtn.disabled = true;
      els.status.textContent = '';
      silentStreakMs = 0; totalChecks = 0; silentChecks = 0; goodAudioMs = 0; startTime = 0; stopTime = 0;
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      stopLevelMonitor();
    }

    // ======= UI wire-up =======
    els.startBtn.onclick = async () => {
      try {
        // Ask for mic with explicit echoCancellation disabled to avoid too-flat waveforms
        stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false } });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = []; hardReset(); // ensures clean state but keeps stream; we will restore stream
        stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false } });
        setupAnalyser(stream);
        startLevelMonitor();

        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };

        mediaRecorder.onstop = () => {
          stopTime = Date.now();
          stopLevelMonitor();
          if (!audioChunks.length){
            els.status.innerHTML = '‚ùå No audio data was captured. Please check your microphone and try again.';
            return;
          }
          audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = document.createElement('audio');
          audio.controls = true; audio.src = audioUrl;
          els.preview.innerHTML = ''; els.preview.appendChild(audio);
          els.deleteBtn.disabled = false; els.submitBtn.disabled = false; els.pauseBtn.disabled = true;

          // Post-stop validation
          const durMs = stopTime - startTime;
          const silentRatio = totalChecks ? (silentChecks/totalChecks) : 1;
          const size = audioBlob.size || 0;
          let problems = [];
          if (durMs < MIN_DURATION_MS) problems.push('The clip is very short');
          if (goodAudioMs < MIN_GOOD_MS) problems.push('We didn\'t detect clear mic input');
          if (silentRatio > 0.95) problems.push('Almost all of the recording was silent');
          if (size < MIN_SIZE_BYTES) problems.push('File size looks too small');

          if (problems.length){
            els.submitBtn.disabled = true;
            els.status.innerHTML = `‚ö†Ô∏è ${problems.join('; ')}. Please check your mic and <strong>record again</strong>.`;
          } else {
            els.status.innerHTML = 'üéß Ready to review.';
          }
        };

        mediaRecorder.start();
        startTime = Date.now(); isPaused = false;
        els.startBtn.disabled = true; els.stopBtn.disabled = false; els.pauseBtn.disabled = false; els.pauseBtn.textContent = 'Pause';
        els.status.textContent = 'üéôÔ∏è Recording‚Ä¶';

        // Track-level mute/inactive detection
        const [track] = stream.getAudioTracks();
        track.onmute = () => { els.status.innerHTML = '‚ö†Ô∏è Your microphone was muted by the system/browser. Unmute to continue.'; };
        track.onunmute = () => { els.status.innerHTML = 'üéôÔ∏è Microphone active again.'; };
        track.onended = () => { if (mediaRecorder && mediaRecorder.state !== 'inactive') { mediaRecorder.stop(); } };

      } catch (err) {
        els.status.innerHTML = '‚ùå Unable to access microphone: ' + (err && err.message ? err.message : err);
      }
    };

    els.pauseBtn.onclick = () => {
      if (!mediaRecorder) return;
      if (!isPaused) { mediaRecorder.pause(); isPaused = true; els.pauseBtn.textContent = 'Resume'; els.status.textContent = '‚è∏Ô∏è Recording paused.'; }
      else { mediaRecorder.resume(); isPaused = false; els.pauseBtn.textContent = 'Pause'; els.status.textContent = 'üéôÔ∏è Recording resumed‚Ä¶'; }
    };

    els.stopBtn.onclick = () => {
      try { mediaRecorder && mediaRecorder.stop(); } catch {}
      els.startBtn.disabled = false; els.stopBtn.disabled = true; els.pauseBtn.disabled = true; els.pauseBtn.textContent = 'Pause';
    };

    els.deleteBtn.onclick = () => {
      audioChunks = []; audioBlob = null; els.preview.innerHTML = '';
      els.deleteBtn.disabled = true; els.submitBtn.disabled = true;
      els.status.textContent = 'üóëÔ∏è Recording deleted. Start again when ready.';
    };

    // üì§ Submit with validation
    els.submitBtn.onclick = async () => {
      if (!audioBlob) { els.status.textContent = '‚ö†Ô∏è No recording found. Please record before submitting.'; return; }

      // Final sanity checks
      const durMs = stopTime - startTime;
      const silentRatio = totalChecks ? (silentChecks/totalChecks) : 1;
      if (durMs < MIN_DURATION_MS || audioBlob.size < MIN_SIZE_BYTES || silentRatio > 0.95 || goodAudioMs < MIN_GOOD_MS){
        els.status.innerHTML = '‚ùå This take looks invalid (too short, silent, or empty). Please record again.'; return;
      }

      const formData = new FormData();
      // Use .webm to match recorded mime type for MediaRecorder default in most browsers
      const safeName = filename.replace(/\.(wav|mp3|m4a)$/i, '') + '.webm';
      formData.append('file', audioBlob, safeName);

      try {
        const response = await fetch('https://hook.eu2.make.com/nsbtpvkksxfjkifpe2our0hxn5ykf6ip', { method: 'POST', body: formData });
        if (response.ok) { els.status.innerHTML = '‚úÖ Recording submitted successfully'; els.submitBtn.disabled = true; els.deleteBtn.disabled = true; }
        else { els.status.textContent = '‚ùå Failed to submit recording.'; }
      } catch (error) { els.status.textContent = '‚ùå Upload error: ' + error.message; }
    };
  </script>
</body>
</html>
