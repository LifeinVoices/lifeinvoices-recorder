<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Record Your Story ‚Äî Safe Recorder (Multi-Take + Auto-Save + Audit Trail)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{ --bg:#ffffff; --fg:#222; --muted:#666; --ok:#2E7D32; --warn:#C0392B; --btn:#ccc; --brand:#1B4D3E; }
    html,body{ background:var(--bg); color:var(--fg) }
    body { font-family: Georgia, serif; text-align:center; margin:40px auto; padding:0 20px; max-width:760px; }
    h1 { margin-bottom:6px; }
    p.lead { margin-top:0; color:var(--muted); }

    /* Buttons: full-width, vertically stacked, consistent size */
    button{
      box-sizing:border-box; display:block; width:100%; max-width:420px;
      font-size:20px; padding:16px 24px; margin:10px auto; border-radius:10px;
      border:none; background:var(--btn); cursor:pointer; box-shadow:0 2px 0 rgba(0,0,0,.08);
    }
    button[disabled]{ opacity:.55; cursor:not-allowed }

    audio { margin:8px auto; display:block; width:100%; max-width:520px; }
    .status { font-size:16px; margin-top:14px; min-height:22px; }
    #logo { margin-top:26px; width:150px; }

    /* Question block */
    #questionWrapper{ margin:20px auto; }
    #questionWrapper h3{ margin:0 0 6px; color:var(--brand); }
    #questionDisplay{ font-style:italic; font-size:18px; color:var(--fg); }

    /* Mic indicator */
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:14px; vertical-align:middle; }
    .pill.ok { background:#E8F5E9; color:var(--ok); }
    .pill.warn { background:#FDECEA; color:var(--warn); }
    .bar-wrap{ margin:8px auto 0; width:240px; height:10px; background:#eee; border-radius:999px; overflow:hidden; }
    .bar{ height:100%; width:0%; background:linear-gradient(90deg, #8BC34A, #FFC107); transition: width .18s linear; }
    .tips { font-size:14px; color:var(--muted); margin-top:10px; }

    /* Takes list */
    .take { text-align:left; margin:10px 0; padding:10px; border:1px solid #eee; border-radius:10px; }
    .take header { display:flex; align-items:center; gap:10px; margin-bottom:6px; }
    .take header label { display:flex; align-items:center; gap:8px; cursor:pointer; }
    .take .meta { font-size:13px; color:#666; }
    .badge { font-size:12px; padding:2px 8px; border-radius:999px; background:#eef; margin-left:8px; }

    @media (max-width:900px){ button{ max-width:520px; } }

    /* Filter row */
    .filters { display:flex; align-items:center; justify-content:center; gap:10px; margin:14px 0 6px; font-size:14px; color:#444; }
    .filters input { transform: translateY(1px); }
  </style>
</head>
<body>
  <h1>Record Your Story</h1>
  <p class="lead">
    Press ‚ÄúStart Recording‚Äù to begin. Click ‚ÄúStop‚Äù to save a take.
    You can record multiple takes and select one or more to submit.
    Your takes are auto-saved and will survive refreshes or crashes.
  </p>

  <!-- Question -->
  <div id="questionWrapper">
    <h3>Question:</h3>
    <div id="questionDisplay"></div>
  </div>

  <!-- Mic health indicator -->
  <div id="micRow" aria-live="polite" style="margin:10px 0 18px;">
    <span id="micPill" class="pill warn">Mic not active</span>
    <div class="bar-wrap" aria-hidden="true"><div id="levelBar" class="bar"></div></div>
    <div class="tips">If the bar doesn't move when you talk, check browser mic permissions and device settings.</div>
  </div>

  <!-- Controls (stacked by CSS) -->
  <button id="startBtn">Start Recording</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="stopBtn" disabled>Stop Recording</button>
  <button id="deleteBtn" disabled>Delete Selected Take(s)</button>
  <button id="submitBtn" disabled>Submit Selected Take(s)</button>

  <!-- Filters -->
  <div class="filters">
    <label><input type="checkbox" id="showSubmitted"> Show submitted takes</label>
  </div>

  <div id="takesContainer" style="margin-top:8px;"></div>
  <div id="status" class="status" role="status" aria-live="polite"></div>

  <img id="logo" src="logo.png" alt="Life In Voices Logo" />

  <script>
    // ======= Configurable thresholds =======
    const SILENCE_THRESHOLD = 0.010;
    const SILENCE_WINDOW_MS = 3000;
    const MIN_GOOD_MS = 1500;
    const MIN_DURATION_MS = 1000;
    const MIN_SIZE_BYTES = 5000;

    // ======= IndexedDB (auto-save) =======
    const DB_NAME = 'liv-recorder';
    const DB_STORE = 'takes';
    let db = null;

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, 2);
        req.onupgradeneeded = (e)=>{
          const d = e.target.result;
          if (!d.objectStoreNames.contains(DB_STORE)){
            const store = d.createObjectStore(DB_STORE, { keyPath:'id', autoIncrement:true });
            store.createIndex('createdAt','createdAt');
          } else {
            const store = e.target.transaction.objectStore(DB_STORE);
            if (!store.indexNames.contains('createdAt')) store.createIndex('createdAt','createdAt');
          }
        };
        req.onsuccess = ()=>{ db = req.result; resolve(db); };
        req.onerror = ()=> reject(req.error);
      });
    }
    const idbAddTake = rec => new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readwrite'); const st=tx.objectStore(DB_STORE); const r=st.add(rec); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); });
    const idbGetAll = () => new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readonly'); const st=tx.objectStore(DB_STORE); const r=st.getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error); });
    const idbPut    = rec => new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readwrite'); const st=tx.objectStore(DB_STORE); const r=st.put(rec); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });
    const idbDelete = id  => new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readwrite'); const st=tx.objectStore(DB_STORE); const r=st.delete(id); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); });

    // ======= Recorder state =======
    let mediaRecorder, audioChunks = [], audioBlob;
    let isPaused = false;
    let stream, audioCtx, analyser, sourceNode;
    let levelTimer = null, startTime = 0, stopTime = 0, silentStreakMs = 0, totalChecks = 0, silentChecks = 0, goodAudioMs = 0;

    // Each take: { id, blob, url, label, durMs, size, createdAt, submitted }
    let takes = [];

    const els = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      deleteBtn: document.getElementById('deleteBtn'),
      submitBtn: document.getElementById('submitBtn'),
      takes: document.getElementById('takesContainer'),
      status: document.getElementById('status'),
      question: document.getElementById('questionDisplay'),
      micPill: document.getElementById('micPill'),
      levelBar: document.getElementById('levelBar'),
      showSubmitted: document.getElementById('showSubmitted'),
    };

    // ======= URL params (filenames + question text) =======
    const urlParams = new URLSearchParams(window.location.search);
    const name = urlParams.get('name') || "unknown";
    const email = urlParams.get('email') || "noemail";
    const week = urlParams.get('week');
    const questionId = urlParams.get('questionId');

    // Accept multiple keys for question text
    const rawText =
      urlParams.get('questionText') ??
      urlParams.get('question') ??
      urlParams.get('q');

    // üé§ Filename base + idempotency key
    const base = questionId ? `LIV_${name}_${email}_${questionId}`
                 : week ? `LIV_${name}_${email}_Week${week}`
                 : `LIV_${name}_${email}`;
    const IDEMPOTENCY_KEY = base;

    // ===== Question display (robust decode + hide if empty) =====
    (function showQuestion(){
      const wrap = document.getElementById('questionWrapper');

      if (!rawText) { if (wrap) wrap.style.display = 'none'; return; }

      // robust decode: handle '+' as spaces and tolerate already-decoded input
      let decoded = rawText;
      try { decoded = decodeURIComponent(String(rawText).replace(/\+/g,' ')); } catch { decoded = rawText; }

      // render
      els.question.textContent = `‚Äú${decoded}‚Äù`;

      // clean URL (remove whichever key was used)
      ['questionText','question','q'].forEach(k => urlParams.delete(k));
      const q = urlParams.toString();
      const cleanUrl = window.location.pathname + (q ? '?' + q : '');
      window.history.replaceState({}, document.title, cleanUrl);
    })();

    // ======= Mic / level helpers =======
    function setupAnalyser(msStream){
      if (audioCtx) { try{ audioCtx.close(); }catch{} }
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(msStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
    }
    function getRMS(){
      const buffer = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(buffer);
      let sum = 0;
      for (let i=0;i<buffer.length;i++){ const v=(buffer[i]-128)/128; sum += v*v; }
      return Math.sqrt(sum / buffer.length);
    }
    function startLevelMonitor(){
      if (!analyser) return;
      const interval = 250;
      levelTimer = setInterval(()=>{
        if (!analyser) return;
        const rms = getRMS();
        els.levelBar.style.width = Math.min(100, Math.round(rms*160)) + '%';
        const now = performance.now();
        totalChecks++;
        if (rms < SILENCE_THRESHOLD){ silentChecks++; silentStreakMs += interval; }
        else { goodAudioMs += interval; silentStreakMs = 0; }
        if (rms < SILENCE_THRESHOLD) { els.micPill.textContent = 'Listening‚Ä¶'; els.micPill.className = 'pill warn'; }
        else { els.micPill.textContent = 'Mic input detected'; els.micPill.className = 'pill ok'; }
        if (startTime && (now - startTime > 1200) && silentStreakMs >= SILENCE_WINDOW_MS){
          els.status.innerHTML = '‚ö†Ô∏è We cannot detect any microphone input. Please check your mic permissions, mute switch, or device settings, then try again.';
        }
      }, interval);
    }
    function stopLevelMonitor(){
      if (levelTimer){ clearInterval(levelTimer); levelTimer = null; }
      if (audioCtx){ try{ audioCtx.close(); }catch{} audioCtx=null; }
      analyser = null; sourceNode = null; els.levelBar.style.width = '0%';
      els.micPill.textContent = 'Mic not active'; els.micPill.className = 'pill warn';
    }

    function resetForNewTake(){
      audioChunks = []; audioBlob = null; isPaused = false;
      els.deleteBtn.disabled = takes.length === 0;
      els.submitBtn.disabled = takes.length === 0;
      els.pauseBtn.disabled = true; els.stopBtn.disabled = true; els.startBtn.disabled = false;
      els.status.textContent = '';
      silentStreakMs = 0; totalChecks = 0; silentChecks = 0; goodAudioMs = 0; startTime = 0; stopTime = 0;
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      stopLevelMonitor();
    }

    function renderTakes(){
      els.takes.innerHTML = '';
      if (!takes.length) return;

      const showSubmitted = els.showSubmitted.checked;
      takes.forEach((t, i) => {
        if (!showSubmitted && t.submitted) return;

        const row = document.createElement('div'); row.className = 'take'; row.dataset.id = t.id;
        const header = document.createElement('header');
        const labelWrap = document.createElement('label');
        const cb = document.createElement('input'); cb.type = 'checkbox'; cb.name = 'selectedTake'; cb.value = String(i);
        if (!t.submitted && i === takes.length - 1) cb.checked = true;

        const title = document.createElement('strong'); title.textContent = `${t.label}`;
        const meta = document.createElement('span'); meta.className = 'meta';
        meta.textContent = ` ‚Äî ${(t.durMs/1000).toFixed(1)}s, ${(t.size/1024).toFixed(0)} KB`;

        labelWrap.appendChild(cb); labelWrap.appendChild(title); labelWrap.appendChild(meta);
        if (t.submitted){ const b=document.createElement('span'); b.className='badge'; b.textContent='submitted'; labelWrap.appendChild(b); }

        header.appendChild(labelWrap); row.appendChild(header);
        const audioEl = document.createElement('audio'); audioEl.controls = true; audioEl.src = t.url; row.appendChild(audioEl);
        els.takes.appendChild(row);
      });

      const anyPending = takes.some(t => !t.submitted);
      els.submitBtn.disabled = !anyPending;
      els.deleteBtn.disabled = takes.length === 0;
    }

    async function hydrateFromDB(){
      try {
        await openDB();
        const all = await idbGetAll();
        all.sort((a,b)=> (a.createdAt||0) - (b.createdAt||0));
        takes = all.map((r, idx)=>({
          id: r.id,
          blob: r.blob,
          url: URL.createObjectURL(r.blob),
          label: r.label || `Take ${idx+1}`,
          durMs: r.durMs || 0,
          size: r.blob ? r.blob.size : (r.size||0),
          createdAt: r.createdAt || Date.now(),
          submitted: !!r.submitted
        }));
        renderTakes();
      } catch (e) { console.warn('IndexedDB load failed', e); }
    }

    window.addEventListener('beforeunload', (e) => { if (takes.length){ e.preventDefault(); e.returnValue = ''; } });
    els.showSubmitted.addEventListener('change', renderTakes);

    // ===== Controls =====
    els.startBtn.onclick = async () => {
      try {
        resetForNewTake();
        stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false } });
        try { const [track] = stream.getAudioTracks(); await track.applyConstraints({ echoCancellation:false, noiseSuppression:false, autoGainControl:false }); } catch {}
        setupAnalyser(stream); startLevelMonitor();

        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };
        mediaRecorder.onstart = () => { startTime = Date.now(); els.status.textContent = 'üéôÔ∏è Recording‚Ä¶'; };
        mediaRecorder.onpause = () => { els.status.textContent = '‚è∏Ô∏è Recording paused.'; };
        mediaRecorder.onresume = () => { els.status.textContent = 'üéôÔ∏è Recording resumed‚Ä¶'; };
        mediaRecorder.onstop = async () => {
          stopTime = Date.now(); stopLevelMonitor();
          if (!audioChunks.length){ els.status.innerHTML = '‚ùå No audio data was captured. Please check your microphone and try again.'; return; }
          audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(audioBlob);
          const durMs = stopTime - startTime; const size = audioBlob.size || 0;
          const label = `Take ${takes.length + 1}`;

          const record = { blob: audioBlob, label, durMs, size, createdAt: Date.now(), submitted:false };
          try {
            await openDB();
            const newId = await idbAddTake(record);
            const take = { id:newId, blob: audioBlob, url: audioUrl, label, durMs, size, createdAt: record.createdAt, submitted:false };
            takes.push(take);
            renderTakes();
            els.pauseBtn.disabled = true;

            if (durMs < MIN_DURATION_MS || size < MIN_SIZE_BYTES){
              els.status.innerHTML = `‚ö†Ô∏è ${label} may be too short or small. You can record another take or delete this one.`;
            } else {
              els.status.innerHTML = `üéß ${label} saved. You can record another take or submit.`;
            }
          } catch (e){
            console.warn('IndexedDB save failed', e);
            const take = { id:null, blob: audioBlob, url: audioUrl, label, durMs, size, createdAt: Date.now(), submitted:false };
            takes.push(take);
            renderTakes();
            els.pauseBtn.disabled = true;
          }
        };

        mediaRecorder.start(250); // flush chunks to avoid missing first words
        isPaused = false;
        els.startBtn.disabled = true; els.stopBtn.disabled = false; els.pauseBtn.disabled = false; els.pauseBtn.textContent = 'Pause';

        const [track] = stream.getAudioTracks();
        track.onmute = () => { els.status.innerHTML = '‚ö†Ô∏è Your microphone was muted by the system/browser. Unmute to continue.'; };
        track.onunmute = () => { els.status.innerHTML = 'üéôÔ∏è Microphone active again.'; };
        track.onended = () => { if (mediaRecorder && mediaRecorder.state !== 'inactive') { try{ mediaRecorder.stop(); }catch{} } };
      } catch (err) { els.status.innerHTML = '‚ùå Unable to access microphone: ' + (err && err.message ? err.message : err); }
    };

    els.pauseBtn.onclick = () => {
      if (!mediaRecorder) return;
      if (!isPaused) { mediaRecorder.pause(); isPaused = true; els.pauseBtn.textContent = 'Resume'; }
      else { mediaRecorder.resume(); isPaused = false; els.pauseBtn.textContent = 'Pause'; }
    };

    els.stopBtn.onclick = () => {
      try { mediaRecorder && mediaRecorder.state !== 'inactive' && mediaRecorder.stop(); } catch {}
      els.startBtn.disabled = false; els.stopBtn.disabled = true; els.pauseBtn.disabled = true; els.pauseBtn.textContent = 'Pause';
    };

    els.deleteBtn.onclick = async () => {
      const selected = Array.from(document.querySelectorAll('input[name="selectedTake"]:checked'));
      if (!selected.length) { els.status.textContent = 'Select at least one take to delete.'; return; }
      const indexes = selected.map(c => parseInt(c.value, 10)).sort((a,b)=>b-a);
      for (const i of indexes){
        const t = takes[i];
        if (t && t.id != null){ try { await openDB(); await idbDelete(t.id); } catch(e){ console.warn('IDB delete failed', e); } }
        try { URL.revokeObjectURL(t.url); } catch{}
        takes.splice(i,1);
      }
      renderTakes();
      els.status.textContent = takes.length ? 'üóëÔ∏è Selected take(s) deleted.' : 'üóëÔ∏è All takes deleted. Start again when ready.';
    };

    // Submit selected takes sequentially; include idempotencyKey; mark submitted; delay between posts
    els.submitBtn.onclick = async () => {
      const selected = Array.from(document.querySelectorAll('input[name="selectedTake"]:checked'));
      if (!selected.length) { els.status.textContent = '‚ö†Ô∏è Select at least one take to submit.'; return; }

      els.submitBtn.disabled = true;
      els.status.innerHTML = 'üì§ Uploading‚Ä¶';

      let ok = 0, fail = 0;
      for (const cb of selected){
        const idx = parseInt(cb.value, 10);
        const chosen = takes[idx];
        if (!chosen || !chosen.blob || chosen.blob.size < MIN_SIZE_BYTES){ fail++; continue; }

        const formData = new FormData();
        const cleanLabel = (chosen.label||'Take').replace(/\s+/g,'');
        const filename = `${base}_${cleanLabel}.webm`;
        formData.append('file', chosen.blob, filename);
        formData.append('idempotencyKey', IDEMPOTENCY_KEY);

        try {
          const response = await fetch('https://hook.eu2.make.com/nsbtpvkksxfjkifpe2our0hxn5ykf6ip', { method: 'POST', body: formData });
          if (response.ok) {
            ok++;
            chosen.submitted = true;
            if (chosen.id != null){
              try {
                await openDB();
                await idbPut({ id: chosen.id, blob: chosen.blob, label: chosen.label, durMs: chosen.durMs, size: chosen.size, createdAt: chosen.createdAt, submitted: true });
              } catch(e){ console.warn('IDB update failed', e); }
            }
          } else { fail++; }
        } catch (e) { fail++; }

        // Give Make a beat between runs so it follows the correct route
        await new Promise(r => setTimeout(r, 750));
      }

      els.status.innerHTML = `üì§ Upload complete: <strong>${ok}</strong> succeeded, <strong>${fail}</strong> failed.`;
      els.submitBtn.disabled = false;
      renderTakes(); // hides newly submitted if toggle is off
    };

    // Hydrate saved takes on load
    hydrateFromDB();
  </script>
</body>
</html>
