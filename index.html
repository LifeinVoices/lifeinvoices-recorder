<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Record Your Story ‚Äî Safe Recorder (Multi-Take + Auto-Save)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{ --bg:#ffffff; --fg:#222; --muted:#666; --accent:#1B4D3E; --warn:#C0392B; --ok:#2E7D32; --btn:#ccc; }
    html,body{background:var(--bg);color:var(--fg)}
    body { font-family: 'Georgia', serif; text-align: center; margin: 40px auto; padding: 0 20px; max-width: 760px; }
    h1 { margin-bottom: 6px; }
    p.lead { margin-top: 0; color: var(--muted); }
    .controls{ display:flex; flex-wrap:wrap; gap:12px; justify-content:center; align-items:center; margin-bottom:6px; }
    .controls-secondary{ display:flex; gap:12px; justify-content:center; align-items:center; margin-bottom:10px; }
    button { font-size: 20px; padding: 14px 22px; border-radius: 10px; border: none; background: var(--btn); cursor: pointer; min-width: 180px; box-shadow: 0 2px 0 rgba(0,0,0,.08); }
    button[disabled]{ opacity:.55; cursor:not-allowed }
    audio { margin: 8px 0; display: block; width: 100%; max-width: 520px; }
    .status { font-size: 16px; margin-top: 14px; min-height: 22px; }
    #logo { margin-top: 26px; width: 150px; }
    #questionDisplay { font-style: italic; max-width: 640px; margin: 12px auto 20px; font-size: 18px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:14px; vertical-align: middle; }
    .pill.ok { background: #E8F5E9; color: var(--ok); }
    .pill.warn { background: #FDECEA; color: var(--warn); }
    .bar-wrap{ margin:8px auto 0; width:240px; height:10px; background:#eee; border-radius:999px; overflow:hidden; }
    .bar{ height:100%; width:0%; background: linear-gradient(90deg, #8BC34A, #FFC107); transition: width .18s linear; }
    .tips { font-size: 14px; color: var(--muted); margin-top: 10px; }
    .take { text-align:left; margin: 10px 0; padding: 10px; border: 1px solid #eee; border-radius: 10px; }
    .take header { display:flex; align-items:center; gap:10px; margin-bottom:6px; }
    .take header label { display:flex; align-items:center; gap:8px; cursor:pointer; }
    .take .meta { font-size: 13px; color: #666; }
    @media (max-width: 480px) { button { font-size: 20px; padding: 16px 20px; min-width: 46%; } }
  </style>
</head>
<body>
  <h1>Record Your Story</h1>
  <p class="lead">Press "Start Recording" to begin. Click "Stop" to save a take. You can record multiple takes and select one or more to submit. Your takes are auto-saved and will survive refreshes or crashes.</p>

  <!-- üß† Display the question -->
  <div id="questionDisplay"></div>

  <!-- Mic health indicator -->
  <div id="micRow" aria-live="polite" style="margin:10px 0 18px;">
    <span id="micPill" class="pill warn">Mic not active</span>
    <div class="bar-wrap" aria-hidden="true"><div id="levelBar" class="bar"></div></div>
    <div class="tips">If the bar doesn't move when you talk, check browser mic permissions and device settings.</div>
  </div>

  <!-- üéôÔ∏è Recording controls -->
  <div class="controls">
    <button id="startBtn">Start Recording</button>
    <button id="pauseBtn" disabled>Pause</button>
  </div>
  <div class="controls-secondary">
    <button id="stopBtn" disabled>Stop Recording</button>
    <button id="deleteBtn" disabled>Delete Selected Take(s)</button>
    <button id="submitBtn" disabled>Submit Selected Take(s)</button>
  </div>

  <div id="takesContainer" style="margin-top: 12px;"></div>
  <div id="status" class="status" role="status" aria-live="polite"></div>

  <img id="logo" src="logo.png" alt="Life In Voices Logo" />

  <script>
    // ======= Configurable thresholds =======
    const SILENCE_THRESHOLD = 0.010;   // lower sensitivity so brief pauses don't flip state
    const SILENCE_WINDOW_MS = 3000;
    const MIN_GOOD_MS = 1500;
    const MIN_DURATION_MS = 1000;
    const MIN_SIZE_BYTES = 5000;

    // ======= IndexedDB (auto-save) =======
    const DB_NAME = 'liv-recorder';
    const DB_STORE = 'takes';
    let db = null;
    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (e)=>{
          const d = e.target.result;
          if (!d.objectStoreNames.contains(DB_STORE)){
            const store = d.createObjectStore(DB_STORE, { keyPath:'id', autoIncrement:true });
            store.createIndex('createdAt','createdAt');
          }
        };
        req.onsuccess = ()=>{ db = req.result; resolve(db); };
        req.onerror = ()=> reject(req.error);
      });
    }
    function idbAddTake(rec){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        const store = tx.objectStore(DB_STORE);
        const req = store.add(rec);
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      });
    }
    function idbGetAll(){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(DB_STORE,'readonly');
        const store = tx.objectStore(DB_STORE);
        const req = store.getAll();
        req.onsuccess = ()=> resolve(req.result || []);
        req.onerror = ()=> reject(req.error);
      });
    }
    function idbDelete(id){
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(DB_STORE,'readwrite');
        const store = tx.objectStore(DB_STORE);
        const req = store.delete(id);
        req.onsuccess = ()=> resolve();
        req.onerror = ()=> reject(req.error);
      });
    }

    let mediaRecorder, audioChunks = [], audioBlob;
    let isPaused = false;
    let stream, audioCtx, analyser, sourceNode;
    let levelTimer = null, startTime = 0, stopTime = 0, silentStreakMs = 0, totalChecks = 0, silentChecks = 0, goodAudioMs = 0;
    // Each take: { id, blob, url, label, durMs, size, createdAt }
    let takes = [];

    const els = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      deleteBtn: document.getElementById('deleteBtn'),
      submitBtn: document.getElementById('submitBtn'),
      takes: document.getElementById('takesContainer'),
      status: document.getElementById('status'),
      question: document.getElementById('questionDisplay'),
      micPill: document.getElementById('micPill'),
      levelBar: document.getElementById('levelBar'),
    };

    const urlParams = new URLSearchParams(window.location.search);
    const name = urlParams.get('name') || "unknown";
    const email = urlParams.get('email') || "noemail";
    const week = urlParams.get('week');
    const questionId = urlParams.get('questionId');
    const rawText = urlParams.get('questionText');

    // üé§ Generate filename base
    let base = questionId ? `LIV_${name}_${email}_${questionId}`
                : week ? `LIV_${name}_${email}_Week${week}`
                : `LIV_${name}_${email}`;

    // üß† Display and decode the question text
    if (rawText) {
      try {
        const cleaned = rawText.trim();
        const decoded = decodeURIComponent(cleaned);
        els.question.textContent = `‚Äú${decoded}‚Äù`;
        urlParams.delete("questionText");
        const cleanUrl = window.location.pathname + "?" + urlParams.toString();
        window.history.replaceState({}, document.title, cleanUrl);
      } catch (e) { els.question.textContent = "‚ùì Unable to display question."; }
    }

    // ======= Mic / level helpers =======
    function setupAnalyser(msStream){
      if (audioCtx) { try{ audioCtx.close(); }catch{} }
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(msStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
    }

    function getRMS(){
      const buffer = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(buffer);
      let sum = 0;
      for (let i=0;i<buffer.length;i++){
        const v = (buffer[i] - 128) / 128; // -1..1
        sum += v*v;
      }
      return Math.sqrt(sum / buffer.length); // 0..1
    }

    function startLevelMonitor(){
      if (!analyser) return;
      const interval = 250; // steadier updates
      levelTimer = setInterval(()=>{
        if (!analyser) return;
        const rms = getRMS();
        els.levelBar.style.width = Math.min(100, Math.round(rms*160)) + '%';
        const now = performance.now();
        totalChecks++;
        if (rms < SILENCE_THRESHOLD){
          silentChecks++; silentStreakMs += interval;
        } else {
          goodAudioMs += interval; silentStreakMs = 0;
        }
        if (rms < SILENCE_THRESHOLD) { els.micPill.textContent = 'Listening‚Ä¶'; els.micPill.className = 'pill warn'; }
        else { els.micPill.textContent = 'Mic input detected'; els.micPill.className = 'pill ok'; }
        if (startTime && (now - startTime > 1200) && silentStreakMs >= SILENCE_WINDOW_MS){
          els.status.innerHTML = '‚ö†Ô∏è We cannot detect any microphone input. Please check your mic permissions, mute switch, or device settings, then try again.';
        }
      }, interval);
    }

    function stopLevelMonitor(){
      if (levelTimer){ clearInterval(levelTimer); levelTimer = null; }
      if (audioCtx){ try{ audioCtx.close(); }catch{} audioCtx=null; }
      analyser = null; sourceNode = null; els.levelBar.style.width = '0%';
      els.micPill.textContent = 'Mic not active'; els.micPill.className = 'pill warn';
    }

    function resetForNewTake(){
      audioChunks = []; audioBlob = null; isPaused = false;
      els.deleteBtn.disabled = takes.length === 0;
      els.submitBtn.disabled = takes.length === 0;
      els.pauseBtn.disabled = true; els.stopBtn.disabled = true; els.startBtn.disabled = false;
      els.status.textContent = '';
      silentStreakMs = 0; totalChecks = 0; silentChecks = 0; goodAudioMs = 0; startTime = 0; stopTime = 0;
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      stopLevelMonitor();
    }

    function renderTakes(){
      els.takes.innerHTML = '';
      if (!takes.length){ return; }
      takes.forEach((t, i) => {
        const row = document.createElement('div'); row.className = 'take'; row.dataset.id = t.id;
        const header = document.createElement('header');
        const labelWrap = document.createElement('label');
        const cb = document.createElement('input'); cb.type = 'checkbox'; cb.name = 'selectedTake'; cb.value = String(i); if (i === takes.length - 1) cb.checked = true;
        const title = document.createElement('strong'); title.textContent = `${t.label}`;
        const meta = document.createElement('span'); meta.className = 'meta'; meta.textContent = ` ‚Äî ${(t.durMs/1000).toFixed(1)}s, ${(t.size/1024).toFixed(0)} KB`;
        labelWrap.appendChild(cb); labelWrap.appendChild(title); labelWrap.appendChild(meta);
        header.appendChild(labelWrap); row.appendChild(header);
        const audioEl = document.createElement('audio'); audioEl.controls = true; audioEl.src = t.url; row.appendChild(audioEl);
        els.takes.appendChild(row);
      });
    }

    async function hydrateFromDB(){
      try {
        await openDB();
        const all = await idbGetAll();
        // sort by createdAt ascending
        all.sort((a,b)=> (a.createdAt||0) - (b.createdAt||0));
        takes = all.map((r, idx)=>({
          id: r.id,
          blob: r.blob,
          url: URL.createObjectURL(r.blob),
          label: r.label || `Take ${idx+1}`,
          durMs: r.durMs || 0,
          size: r.blob ? r.blob.size : (r.size||0),
          createdAt: r.createdAt || Date.now()
        }));
        renderTakes();
        els.deleteBtn.disabled = takes.length === 0;
        els.submitBtn.disabled = takes.length === 0;
      } catch (e) {
        console.warn('IndexedDB load failed', e);
      }
    }

    // Warn on accidental refresh if there are takes
    window.addEventListener('beforeunload', (e) => {
      if (takes.length){ e.preventDefault(); e.returnValue = ''; }
    });

    // ======= UI wire-up =======
    els.startBtn.onclick = async () => {
      try {
        resetForNewTake();
        stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
        });
        try { const [track] = stream.getAudioTracks(); await track.applyConstraints({ echoCancellation: false, noiseSuppression: false, autoGainControl: false }); } catch {}
        setupAnalyser(stream); startLevelMonitor();

        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };
        mediaRecorder.onstart = () => { startTime = Date.now(); els.status.textContent = 'üéôÔ∏è Recording‚Ä¶'; };
        mediaRecorder.onpause = () => { els.status.textContent = '‚è∏Ô∏è Recording paused.'; };
        mediaRecorder.onresume = () => { els.status.textContent = 'üéôÔ∏è Recording resumed‚Ä¶'; };
        mediaRecorder.onstop = async () => {
          stopTime = Date.now(); stopLevelMonitor();
          if (!audioChunks.length){ els.status.innerHTML = '‚ùå No audio data was captured. Please check your microphone and try again.'; return; }
          audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(audioBlob);
          const durMs = stopTime - startTime; const size = audioBlob.size || 0;
          const label = `Take ${takes.length + 1}`;

          // Persist to IndexedDB first
          const record = { blob: audioBlob, label, durMs, size, createdAt: Date.now() };
          try {
            await openDB();
            const newId = await idbAddTake(record);
            const take = { id:newId, blob: audioBlob, url: audioUrl, label, durMs, size, createdAt: record.createdAt };
            takes.push(take);
            renderTakes();
            els.deleteBtn.disabled = false; els.submitBtn.disabled = false; els.pauseBtn.disabled = true;

            if (durMs < MIN_DURATION_MS || size < MIN_SIZE_BYTES){ els.status.innerHTML = `‚ö†Ô∏è ${label} may be too short or small. You can record another take or delete this one.`; }
            else { els.status.innerHTML = `üéß ${label} saved. You can record another take or submit.`; }
          } catch (e){
            // If DB fails, still keep it in memory
            console.warn('IndexedDB save failed', e);
            const take = { id: null, blob: audioBlob, url: audioUrl, label, durMs, size, createdAt: Date.now() };
            takes.push(take);
            renderTakes();
            els.deleteBtn.disabled = false; els.submitBtn.disabled = false; els.pauseBtn.disabled = true;
          }
        };

        mediaRecorder.start(250); // flush chunks while recording
        isPaused = false; els.startBtn.disabled = true; els.stopBtn.disabled = false; els.pauseBtn.disabled = false; els.pauseBtn.textContent = 'Pause';

        const [track] = stream.getAudioTracks();
        track.onmute = () => { els.status.innerHTML = '‚ö†Ô∏è Your microphone was muted by the system/browser. Unmute to continue.'; };
        track.onunmute = () => { els.status.innerHTML = 'üéôÔ∏è Microphone active again.'; };
        track.onended = () => { if (mediaRecorder && mediaRecorder.state !== 'inactive') { try{ mediaRecorder.stop(); }catch{} } };
      } catch (err) {
        els.status.innerHTML = '‚ùå Unable to access microphone: ' + (err && err.message ? err.message : err);
      }
    };

    els.pauseBtn.onclick = () => {
      if (!mediaRecorder) return;
      if (!isPaused) { mediaRecorder.pause(); isPaused = true; els.pauseBtn.textContent = 'Resume'; }
      else { mediaRecorder.resume(); isPaused = false; els.pauseBtn.textContent = 'Pause'; }
    };

    els.stopBtn.onclick = () => {
      try { mediaRecorder && mediaRecorder.state !== 'inactive' && mediaRecorder.stop(); } catch {}
      els.startBtn.disabled = false; els.stopBtn.disabled = true; els.pauseBtn.disabled = true; els.pauseBtn.textContent = 'Pause';
    };

    els.deleteBtn.onclick = async () => {
      const selected = Array.from(document.querySelectorAll('input[name="selectedTake"]:checked'));
      if (!selected.length) { els.status.textContent = 'Select at least one take to delete.'; return; }
      // Delete in reverse order to keep indices valid
      const indexes = selected.map(c => parseInt(c.value, 10)).sort((a,b)=>b-a);
      for (const i of indexes){
        const t = takes[i];
        if (t && t.id != null){ try { await openDB(); await idbDelete(t.id); } catch(e){ console.warn('IDB delete failed', e); } }
        try { URL.revokeObjectURL(t.url); } catch{}
        takes.splice(i,1);
      }
      renderTakes();
      els.submitBtn.disabled = takes.length === 0; els.deleteBtn.disabled = takes.length === 0;
      els.status.textContent = takes.length ? 'üóëÔ∏è Selected take(s) deleted.' : 'üóëÔ∏è All takes deleted. Start again when ready.';
    };

    // üì§ Submit selected take(s) ‚Äî sequential POSTs
    els.submitBtn.onclick = async () => {
      const selected = Array.from(document.querySelectorAll('input[name="selectedTake"]:checked'));
      if (!selected.length) { els.status.textContent = '‚ö†Ô∏è Select at least one take to submit.'; return; }

      els.submitBtn.disabled = true; // prevent double clicks
      els.status.innerHTML = 'üì§ Uploading‚Ä¶';

      let ok = 0, fail = 0;
      for (const cb of selected){
        const idx = parseInt(cb.value, 10);
        const chosen = takes[idx];
        if (!chosen || !chosen.blob || chosen.blob.size < MIN_SIZE_BYTES){ fail++; continue; }
        const formData = new FormData();
        const cleanLabel = (chosen.label||'Take').replace(/\\s+/g,'');
        const filename = `${base}_${cleanLabel}.webm`;
        formData.append('file', chosen.blob, filename);
        try {
          const response = await fetch('https://hook.eu2.make.com/nsbtpvkksxfjkifpe2our0hxn5ykf6ip', { method: 'POST', body: formData });
          if (response.ok) ok++; else fail++;
        } catch (e) { fail++; }
      }

      els.status.innerHTML = `üì§ Upload complete: <strong>${ok}</strong> succeeded, <strong>${fail}</strong> failed.`;
      if (ok === 0) { els.submitBtn.disabled = false; }
    };

    // Hydrate saved takes on load
    hydrateFromDB();
  </script>
</body>
</html>
