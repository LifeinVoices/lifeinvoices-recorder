<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Record Your Story ‚Äî Safe Recorder (Multi‚ÄëTake)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{ --bg:#ffffff; --fg:#222; --muted:#666; --accent:#1B4D3E; --warn:#C0392B; --ok:#2E7D32; --btn:#ccc; }
    html,body{background:var(--bg);color:var(--fg)}
    body { font-family: 'Georgia', serif; text-align: center; margin: 40px auto; padding: 0 20px; max-width: 760px; }
    h1 { margin-bottom: 6px; }
    p.lead { margin-top: 0; color: var(--muted); }
    button { font-size: 20px; padding: 16px 28px; margin: 12px; border-radius: 10px; border: none; background: var(--btn); cursor: pointer; min-width: 200px; box-shadow: 0 2px 0 rgba(0,0,0,.08); }
    button[disabled]{ opacity:.55; cursor:not-allowed }
    audio { margin: 8px 0; display: block; width: 100%; max-width: 520px; }
    .status { font-size: 16px; margin-top: 14px; min-height: 22px; }
    #logo { margin-top: 26px; width: 150px; }
    #questionDisplay { font-style: italic; max-width: 640px; margin: 12px auto 20px; font-size: 18px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; font-size:14px; vertical-align: middle; }
    .pill.ok { background: #E8F5E9; color: var(--ok); }
    .pill.warn { background: #FDECEA; color: var(--warn); }
    .bar-wrap{ margin:8px auto 0; width:240px; height:10px; background:#eee; border-radius:999px; overflow:hidden; }
    .bar{ height:100%; width:0%; background: linear-gradient(90deg, #8BC34A, #FFC107); transition: width .18s linear; }
    .tips { font-size: 14px; color: var(--muted); margin-top: 10px; }
    .take { text-align:left; margin: 10px 0; padding: 10px; border: 1px solid #eee; border-radius: 10px; }
    .take header { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    @media (max-width: 480px) { button { font-size: 22px; padding: 18px 32px; min-width: 90%; } }
  </style>
</head>
<body>
  <h1>Record Your Story</h1>
  <p class="lead">Press "Start Recording" to begin. Click "Stop Recording" to save a take. You can record multiple takes and choose one or more to submit.</p>

  <!-- üß† Display the question -->
  <div id="questionDisplay"></div>

  <!-- Mic health indicator -->
  <div id="micRow" aria-live="polite" style="margin:10px 0 18px;">
    <span id="micPill" class="pill warn">Mic not active</span>
    <div class="bar-wrap" aria-hidden="true"><div id="levelBar" class="bar"></div></div>
    <div class="tips">If the bar doesn't move when you talk, check browser mic permissions and device settings.</div>
  </div>

  <!-- üéôÔ∏è Recording controls -->
  <div>
    <button id="startBtn">Start Recording</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="stopBtn" disabled>Stop Recording</button>
    <button id="deleteBtn" disabled>Delete Selected Takes</button>
    <button id="submitBtn" disabled>Submit Selected Takes</button>
  </div>

  <div id="takesContainer" style="margin-top: 12px;"></div>
  <div id="status" class="status" role="status" aria-live="polite"></div>

  <img id="logo" src="logo.png" alt="Life In Voices Logo" />

  <script>
    const SILENCE_THRESHOLD = 0.010;
    const SILENCE_WINDOW_MS = 3000;
    const MIN_GOOD_MS = 1500;
    const MIN_DURATION_MS = 1000;
    const MIN_SIZE_BYTES = 5000;

    let mediaRecorder, audioChunks = [], audioBlob;
    let isPaused = false;
    let stream, audioCtx, analyser, sourceNode;
    let levelTimer = null, startTime = 0, stopTime = 0, silentStreakMs = 0, totalChecks = 0, silentChecks = 0, goodAudioMs = 0;
    let takes = [];

    const els = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      deleteBtn: document.getElementById('deleteBtn'),
      submitBtn: document.getElementById('submitBtn'),
      takes: document.getElementById('takesContainer'),
      status: document.getElementById('status'),
      question: document.getElementById('questionDisplay'),
      micPill: document.getElementById('micPill'),
      levelBar: document.getElementById('levelBar'),
    };

    function setupAnalyser(msStream){
      if (audioCtx) { try{ audioCtx.close(); }catch{} }
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(msStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      sourceNode.connect(analyser);
    }

    function getRMS(){
      const buffer = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(buffer);
      let sum = 0;
      for (let i=0;i<buffer.length;i++){
        const v = (buffer[i] - 128) / 128;
        sum += v*v;
      }
      return Math.sqrt(sum / buffer.length);
    }

    function startLevelMonitor(){
      if (!analyser) return;
      const interval = 250;
      levelTimer = setInterval(()=>{
        if (!analyser) return;
        const rms = getRMS();
        els.levelBar.style.width = Math.min(100, Math.round(rms*160)) + '%';
        const now = performance.now();
        totalChecks++;
        if (rms < SILENCE_THRESHOLD){ silentChecks++; silentStreakMs += interval; }
        else { goodAudioMs += interval; silentStreakMs = 0; }
        if (rms < SILENCE_THRESHOLD) { els.micPill.textContent = 'Listening‚Ä¶'; els.micPill.className = 'pill warn'; }
        else { els.micPill.textContent = 'Mic input detected'; els.micPill.className = 'pill ok'; }
      }, interval);
    }

    function stopLevelMonitor(){ if (levelTimer){ clearInterval(levelTimer); levelTimer = null; } }

    function resetForNewTake(){
      audioChunks = []; audioBlob = null; isPaused = false;
      els.deleteBtn.disabled = takes.length === 0;
      els.submitBtn.disabled = takes.length === 0;
      els.pauseBtn.disabled = true; els.stopBtn.disabled = true; els.startBtn.disabled = false;
      els.status.textContent = '';
      silentStreakMs = 0; totalChecks = 0; silentChecks = 0; goodAudioMs = 0; startTime = 0; stopTime = 0;
      if (stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      stopLevelMonitor();
    }

    function renderTakes(){
      els.takes.innerHTML = '';
      takes.forEach((t, i) => {
        const row = document.createElement('div'); row.className = 'take';
        const header = document.createElement('header');
        const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.name = 'selectedTake'; checkbox.value = String(i);
        const title = document.createElement('strong'); title.textContent = `${t.label}`;
        header.appendChild(checkbox); header.appendChild(title); row.appendChild(header);
        const audioEl = document.createElement('audio'); audioEl.controls = true; audioEl.src = t.url; row.appendChild(audioEl);
        els.takes.appendChild(row);
      });
    }

    els.startBtn.onclick = async () => {
      try {
        resetForNewTake();
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        setupAnalyser(stream); startLevelMonitor();

        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };
        mediaRecorder.onstart = () => { startTime = Date.now(); els.status.textContent = 'üéôÔ∏è Recording‚Ä¶'; };
        mediaRecorder.onstop = () => {
          stopTime = Date.now(); stopLevelMonitor();
          if (!audioChunks.length){ els.status.innerHTML = '‚ùå No audio data was captured.'; return; }
          audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(audioBlob);
          const takeIndex = takes.length + 1; const label = `Take ${takeIndex}`;
          takes.push({ blob: audioBlob, url: audioUrl, label });
          renderTakes();
          els.deleteBtn.disabled = false; els.submitBtn.disabled = false; els.pauseBtn.disabled = true;
          els.status.innerHTML = `üéß ${label} saved.`;
        };

        mediaRecorder.start(250);
        isPaused = false; els.startBtn.disabled = true; els.stopBtn.disabled = false; els.pauseBtn.disabled = false; els.pauseBtn.textContent = 'Pause';
      } catch (err) { els.status.innerHTML = '‚ùå Unable to access microphone: ' + err.message; }
    };

    els.pauseBtn.onclick = () => {
      if (!mediaRecorder) return;
      if (!isPaused) { mediaRecorder.pause(); isPaused = true; els.pauseBtn.textContent = 'Resume'; els.status.textContent = '‚è∏Ô∏è Recording paused.'; }
      else { mediaRecorder.resume(); isPaused = false; els.pauseBtn.textContent = 'Pause'; els.status.textContent = 'üéôÔ∏è Recording resumed‚Ä¶'; }
    };

    els.stopBtn.onclick = () => {
      try { mediaRecorder && mediaRecorder.state !== 'inactive' && mediaRecorder.stop(); } catch {}
      els.startBtn.disabled = false; els.stopBtn.disabled = true; els.pauseBtn.disabled = true; els.pauseBtn.textContent = 'Pause';
    };

    els.deleteBtn.onclick = () => {
      const selected = Array.from(document.querySelectorAll('input[name="selectedTake"]:checked')).map(cb => parseInt(cb.value,10));
      if (!selected.length) return;
      takes = takes.filter((t,i) => !selected.includes(i));
      renderTakes();
      els.submitBtn.disabled = takes.length === 0; els.deleteBtn.disabled = takes.length === 0;
      els.status.textContent = takes.length ? 'üóëÔ∏è Selected take(s) deleted.' : 'üóëÔ∏è All takes deleted.';
    };

    els.submitBtn.onclick = async () => {
      const selected = Array.from(document.querySelectorAll('input[name="selectedTake"]:checked')).map(cb => parseInt(cb.value,10));
      if (!selected.length) { els.status.textContent = '‚ö†Ô∏è No take selected.'; return; }

      for (const idx of selected){
        const chosen = takes[idx];
        if (!chosen || !chosen.blob) continue;
        const formData = new FormData();
        const filename = `${base}_Take${idx+1}.webm`;
        formData.append('file', chosen.blob, filename);
        try {
          const response = await fetch('https://hook.eu2.make.com/nsbtpvkksxfjkifpe2our0hxn5ykf6ip', { method: 'POST', body: formData });
          if (response.ok) { els.status.innerHTML = '‚úÖ Selected take(s) submitted successfully'; }
          else { els.status.textContent = '‚ùå Failed to submit.'; }
        } catch (error) { els.status.textContent = '‚ùå Upload error: ' + error.message; }
      }
      els.submitBtn.disabled = true; els.deleteBtn.disabled = true;
    };
  </script>
</body>

<!-- end -->
